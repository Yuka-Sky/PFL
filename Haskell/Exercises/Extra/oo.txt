2. Now consider a small imperative programming language with arithmetic and boolean expressions, and statements consisting of assignments of the form x := a, sequence of statements (instr1 ; instr2), if then else statements, and while loops.
One can now define a translation (a compiler) from this language into lists of instructions in the previous machine.
• Arithmetic and boolean expressions will be evaluated on the evaluation stack of the machine and the code to be generated must effect this. Thus, the code generated for binary expressions consists of the code for the right argument followed by that for the left argument and, finally, the appropriate instruction for the operator. In this way, it is ensured that the arguments appear on the evaluation stack in the
order required by the instructions.
Example 3 The compilation of x + 1 is [push − 1, fetch − x, add].
The code generated for an arithmetic expression must ensure that the value of the expression is on top of the evaluation stack when it has been computed.
• The code generated for x := a appends the code for the arithmetic expression a with the instruction store−x. This instruction assigns x the appropriate value and additionally pops the stack.
• For a sequence of two statements, we just concatenate the two instruction sequences.
• When generating code for the conditional, the code for the boolean expression will ensure that a truth value will be placed on top of the evaluation stack, and the branch instruction will then inspect (and pop) that value and select the appropriate piece of code.
• Finally, the code for the while statement uses the loop-instruction.
Example 4 The compilation of the factorial program
y := 1; while ¬(x = 1) do (y := y ∗ x; x := x − 1)
outputs the code:
[push-1,store-y,loop([push-1,fetch-x,eq,neg],
[fetch-x,fetch-y,mult,store-y,push-1,fetch-x,sub,store-x)])]
(a) Define three datas in Haskell to represent expressions and statements of this imperative language:
• Aexp for arithmetic expressions
• Bexp for boolean expressions
• Stm for statements
(b) Define a compiler from a program in this small imperative language into a list of machine instructions (as defined in part 1). The main compiler is function:
• compile :: [Stm] → Code
that must use the two mandatory auxiliary functions which compile arithmetic and boolean expressions, respectively:
• compA :: Aexp → Code
• compB :: Bexp → Code
(c) Define a parser which transforms an imperative program represented as a string into its corresponding representation in the Stm data (a list of statements Stm).
The parser2
function must have the following signature:
• parse :: String → [Stm]
The string representing the program has the following syntactic constraints:
• All statements end with a semicolon (;).
• The string may contain spaces between each token (a token is basically a sequence of characters that are treated as a unit as it cannot be further broken down. Examples of tokens are the keywords (while, if, then, else, etc.), variables, operators (+, - , *), delimiters/punctuators like the semicolon(;) or
brackets, etc. integers and boolean values are also tokens).
You may either implement the parser directly in Haskell or study and use the parser library Parsec.
• Variables begin with a lowercase letter (assume that no variable name can contain a reserved keyword as a substring. For instance, anotherVar is an invalid variable name as it contains the keyword not).
• Operator precedence in arithmetic expressions is the usual: multiplications are performed before additions and subtractions. Additions and subtractions have the same level of precedence and are executed from left to right (i.e. they are left-associative). Multiplications are also left-associative.
• Parentheses may be used to add priority to an operation. For instance, 1+2*3 = 7 but (1+2)*3 = 9.
• In boolean expressions, two instances of the same operator are also computed from left to right. The order of precedence for the operations is (with the first one being executed first): integer inequality (≤), integer equality (==), logical negation (not), boolean equality (=), logical conjunction (and). For instance, not True and 2 ≤ 5 = 3 == 4 is equivalent to (not True) and ((2 ≤ 5) = (3 == 4)).
Hint: define an auxiliary function lexer :: String → [String] that splits the string into a list of words (tokens). Example: lexer ”23 + 4 * 421” = [”23”,”+”,”4”,”*”,”421”] and from this list of tokens build the corresponding data, i.e. parse = buildData . lexer




